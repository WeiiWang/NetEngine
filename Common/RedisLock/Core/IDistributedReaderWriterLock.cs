using System;
using System.Threading;
using System.Threading.Tasks;

namespace Common.RedisLock.Core
{
    /// <summary>
    /// 提供类似于 <see cref="ReaderWriterLock"/> 的分布式锁定功能
    /// </summary>
    public interface IDistributedReaderWriterLock
    {
        /// <summary>
        /// A name that uniquely identifies the lock
        /// </summary>
        string Name { get; }

        /// <summary>
        /// 尝试同步获取 READ 锁。 允许多个阅读器。 与 WRITE 锁不兼容。 用法：
        /// <code>
        ///     using (var handle = myLock.TryAcquireReadLock(...))
        ///     {
        ///         if (handle != null) { /* we have the lock! */ }
        ///     }
        ///     // dispose releases the lock if we took it
        /// </code>
        /// </summary>
        /// <param name="timeout">在放弃获取尝试之前等待多长时间。 默认为 0</param>
        /// <param name="cancellationToken">指定可以取消等待的令牌</param>
        /// <returns>一个 <see cref="IDistributedSynchronizationHandle"/> 可用于释放锁或在失败时为空</returns>
        IDistributedSynchronizationHandle? TryAcquireReadLock(TimeSpan timeout = default, CancellationToken cancellationToken = default);

        /// <summary>
        /// 同步获取 READ 锁，如果尝试超时，则失败并返回 <see cref="TimeoutException"/>。 允许多个阅读器。 与 WRITE 锁不兼容。 用法：
        /// <code>
        ///     using (myLock.AcquireReadLock(...))
        ///     {
        ///         /* we have the lock! */
        ///     }
        ///     // dispose releases the lock
        /// </code>
        /// </summary>
        /// <param name="timeout">在放弃获取尝试之前等待多长时间。 默认为 <see cref="Timeout.InfiniteTimeSpan"/></param>
        /// <param name="cancellationToken">指定可以取消等待的令牌</param>
        /// <returns>一个<see cref="IDistributedSynchronizationHandle"/>可以用来释放锁</returns>
        IDistributedSynchronizationHandle AcquireReadLock(TimeSpan? timeout = null, CancellationToken cancellationToken = default);

        /// <summary>
        /// 尝试异步获取 READ 锁。 允许多个阅读器。 与 WRITE 锁不兼容。 用法：
        /// <code>
        ///     await using (var handle = await myLock.TryAcquireReadLockAsync(...))
        ///     {
        ///         if (handle != null) { /* we have the lock! */ }
        ///     }
        ///     // dispose releases the lock if we took it
        /// </code>
        /// </summary>
        /// <param name="timeout">在放弃获取尝试之前等待多长时间。 默认为 0</param>
        /// <param name="cancellationToken">指定可以取消等待的令牌</param>
        /// <returns>一个 <see cref="IDistributedSynchronizationHandle"/> 可用于释放锁或在失败时为空</returns>
        ValueTask<IDistributedSynchronizationHandle?> TryAcquireReadLockAsync(TimeSpan timeout = default, CancellationToken cancellationToken = default);

        /// <summary>
        /// 异步获取 READ 锁，如果尝试超时，则失败并返回 <see cref="TimeoutException"/>。 允许多个阅读器。 与 WRITE 锁不兼容。 用法：
        /// <code>
        ///     await using (await myLock.AcquireReadLockAsync(...))
        ///     {
        ///         /* we have the lock! */
        ///     }
        ///     // dispose releases the lock
        /// </code>
        /// </summary>
        /// <param name="timeout">在放弃获取尝试之前等待多长时间。 默认为 <see cref="Timeout.InfiniteTimeSpan"/></param>
        /// <param name="cancellationToken">指定可以取消等待的令牌</param>
        /// <returns>一个<see cref="IDistributedSynchronizationHandle"/>可以用来释放锁</returns>
        ValueTask<IDistributedSynchronizationHandle> AcquireReadLockAsync(TimeSpan? timeout = null, CancellationToken cancellationToken = default);

        /// <summary>
        /// 尝试同步获取 WRITE 锁。 与另一个 WRITE 锁或 UPGRADE 锁不兼容。 用法：
        /// <code>
        ///     using (var handle = myLock.TryAcquireWriteLock(...))
        ///     {
        ///         if (handle != null) { /* we have the lock! */ }
        ///     }
        ///     // dispose releases the lock if we took it
        /// </code>
        /// </summary>
        /// <param name="timeout">在放弃获取尝试之前等待多长时间。 默认为 0</param>
        /// <param name="cancellationToken">指定可以取消等待的令牌</param>
        /// <returns>一个 <see cref="IDistributedSynchronizationHandle"/> 可用于释放锁或在失败时为空</returns>
        IDistributedSynchronizationHandle? TryAcquireWriteLock(TimeSpan timeout = default, CancellationToken cancellationToken = default);

        /// <summary>
        /// 同步获取 WRITE 锁，如果尝试超时，则失败并返回 <see cref="TimeoutException"/>。 与另一个 WRITE 锁或 UPGRADE 锁不兼容。 用法：
        /// <code>
        ///     using (myLock.AcquireWriteLock(...))
        ///     {
        ///         /* we have the lock! */
        ///     }
        ///     // dispose releases the lock
        /// </code>
        /// </summary>
        /// <param name="timeout">在放弃获取尝试之前等待多长时间。 默认为 <see cref="Timeout.InfiniteTimeSpan"/></param>
        /// <param name="cancellationToken">指定可以取消等待的令牌</param>
        /// <returns>一个<see cref="IDistributedSynchronizationHandle"/>可以用来释放锁</returns>
        IDistributedSynchronizationHandle AcquireWriteLock(TimeSpan? timeout = null, CancellationToken cancellationToken = default);

        /// <summary>
        /// 尝试异步获取 WRITE 锁。 与另一个 WRITE 锁或 UPGRADE 锁不兼容。 用法：
        /// <code>
        ///     await using (var handle = await myLock.TryAcquireWriteLockAsync(...))
        ///     {
        ///         if (handle != null) { /* we have the lock! */ }
        ///     }
        ///     // dispose releases the lock if we took it
        /// </code>
        /// </summary>
        /// <param name="timeout">在放弃获取尝试之前等待多长时间。 默认为 0</param>
        /// <param name="cancellationToken">指定可以取消等待的令牌</param>
        /// <returns>一个 <see cref="IDistributedSynchronizationHandle"/> 可用于释放锁或在失败时为空</returns>
        ValueTask<IDistributedSynchronizationHandle?> TryAcquireWriteLockAsync(TimeSpan timeout = default, CancellationToken cancellationToken = default);

        /// <summary>
        /// 异步获取 WRITE 锁，如果尝试超时，则失败并返回 <see cref="TimeoutException"/>。 与另一个 WRITE 锁或 UPGRADE 锁不兼容。 用法：
        /// <code>
        ///     await using (await myLock.AcquireWriteLockAsync(...))
        ///     {
        ///         /* we have the lock! */
        ///     }
        ///     // dispose releases the lock
        /// </code>
        /// </summary>
        /// <param name="timeout">在放弃获取尝试之前等待多长时间。 默认为 <see cref="Timeout.InfiniteTimeSpan"/></param>
        /// <param name="cancellationToken">指定可以取消等待的令牌</param>
        /// <returns>一个<see cref="IDistributedSynchronizationHandle"/>可以用来释放锁</returns>
        ValueTask<IDistributedSynchronizationHandle> AcquireWriteLockAsync(TimeSpan? timeout = null, CancellationToken cancellationToken = default);
    }
}
